# Long message attack

# Description

# Summary:
This folder has two main executable `long_message_attack_parallel` and `verify_hash' which generates two colliding messages and verifies the results, respectively.

# definitions
long message: a large message of zeros.

## Usage:
Basic usage:
### Generate colliding messages
./long_message_attack n l

This will mount an attack of truncated sha256 to n-bits using a long message of length 2^l. The random message that collides with the long message can be found in `messages/n_l` in binary format (read it as unsigned char[64]). Also, you can find benchmark and the index where the collision occurs at `statistics_parallel/n_l.txt`.  Substitute n and l, if l>= n/2 then there is a high chance of having a cycle. In this case, you can only find a file in `statistics_parallel/n_l.txt`


### Verifies the results
./verify_hash "messages/n_l" n
This will read the file n_l, truncate the output to n bits, and search for an index where the message found in `messages/n_l` collides with the long message. If it find an index, it will print it or it will continue the search forever.




# compile:
run `make` and the executable `long_message_attack` is the a parallel version of the attack, apologies for the confusion with what written below.

## Flags
`-fopenmp` for parallel executable (only Phase II can be parallel)
`-DVERBOSE_LEVEL` print intermediate information (it will flood the program use with care)


- parallel
gcc -fopenmp -O3 long_message_attack.c sha256.c dict.c util/util_char_arrays.c util/memory.c -lm -o long_message_attack_parallel

// DEBUG
gcc -DVERBOSE_LEVEL -fopenmp -O3  -g long_message_attack.c sha256.c dict.c util/util_char_arrays.c util/memory.c -lm -o long_message_attack_parallel




- serial
gcc -O3  -g long_message_attack.c sha256.c dict.c util/util_char_arrays.c util/memory.c -lm -o long_message_attack

// with debug using
gcc -DVERBOSE_LEVEL -O3  -g long_message_attack.c sha256.c dict.c util/util_char_arrays.c util/memory.c -lm -o long_message_attack



- verify hash
gcc -g verify_hash.c sha256.c -lm -o verify_hash

cost statistics:
sudo perf stat -a  -e power/energy-pkg/ ./long_message_attack_parallel 63 29

sudo perf stat -o stats.txt -a -r 2 -e power/energy-pkg/ ./long_message_attack 30 15


sudo perf stat -a -r 2 -e power/energy-pkg/ ./long_message_attack 30 15

usage:
./longa_message_attack n l
n: 0<n<257 which is the number of bits in the output of the compression function
l:float 2^l is the number of blocks

- the two messages, that collide, will be saved in the files `message1` `message2`


files:
- 
- statistics*/n_l_bits.txt files contain the system power usage while the program was running.
- long_message_attack.c: main file that implements the attack
- verify_hash.c: reads 64 bytes from a binary file then it hashes a long message till a collision is found.
                 returns the index idx where the collision occurs.
- dict.*: chained dictionary implementation using linked list
- util_char_arrays.* : some useful functionalities
- ignore the tmp file



taken from the internet: 
- sha256.* (modified)
- crypto-algorithms-master.zip
- memory.c

questions:


issues:


future improvements:


possible optimizations:
- profile the code


Benchmarks:
- Number of sha256 transforms ~2^21 calls / sec
- Memory writes ~100MB/sec
